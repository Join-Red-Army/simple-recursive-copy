# simple-recursive-copy  

Чтобы потренироваться в рекурсии, я попробовал написать простую программу для создания независимых копий объектов, которые содержат вложенные объекты.  

Примитивные типы (строки, числа, логические значения) присваиваются и копируются «по значению». В результате мы имеем две независимые переменные.  
Объекты ведут себя иначе. Переменная хранит не сам объект, а его адрес в памяти, ссылку на него.Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется. В результате появляются две переменные, каждая из которых содержит ссылку на один и тот же объект.
  
Есть несколько способов сделать "независимую" копию объекта:  
С использованием оператора rest:
```javaScript
let copy = {...original};
```
Через метод Object.assign:
```javaScript
Object.assign(target, ...sources)

var object = { key1: 'value1', key2: 'value2' };
var copy = Object.assign({}, object);
```
Собрать новый объект из ключей и значений:
```javaScript
function getObjectCopy(originalObject) {
  var copy = {};
  var keys = Object.keys(originalObject);
  var values = Object.values(originalObject);

  for(var i = 0; i < keys.length; i += 1) {
    copy[keys[i]] = values[i];
  }
  return copy;
};
```
Эти способы хорошо работают только в том случае, если объект среди своих свойств не содержит вложенный объект. Вложенные объекты не получат независимую копию и всё так же будут доступны по ссылке.  
  
 
После создания программы, на практике всплыли некоторые проблемы: массивы, функции и другие структуры данных являются объектами и проходят проверку на ```instanceof``` и ```typeof```. Похоже, что для создания рекурсивных копий всего и вся пришлось бы писать отдельные модули для каждой структуры. Примерно таким образом поступили Lodash в своём _.cloneDeep.  
В принципе, можно заморочиться и попробовать решить эти проблемы. Например, функции можно не копировать, в этом смысла мало, а сделать рекурсивную копию массива вообще легко, даже если среди его элементов будет объект. Пусть это будет задача на будущее. Сейчас более-менее понятно, как её решить, но я всё-таки хотел потренироваться работать с рекурсией, а не создавать конкурента _.cloneDeep.  
  
Основная идея программы - пересобирать вложенные объекты. Для этого надо спускаться по дочерним элементам вниз до тех пор, пока не останутся только листья, и передавать наверх независимые копии нижестоящих объектов. Если встречается примитив, то он просто записывается в копию текущего объекта. 
  
  
  Код программы, чтобы не кликать в файл:
```javaScript
// вспомогательная функция
// проверка на наличие вложенных объектов
function hasInnerObjects(obj) {
  return Object.values(obj).some((element) => typeof element === 'object');
};


// основная функция 
function recursiveCopy(obj) {
  const result = {};
  const pairs = Object.entries(obj);

  // терминальное условие
  if (!hasInnerObjects(obj)) {
    Object.assign(result, obj);
    return result;
  }

  // если присутствуют вложенные объекты
  pairs.forEach(([key, value]) => {
    if (value instanceof Object) {
      value = recursiveCopy(value);      
    }
    result[key] = value;
  });

  return result;
};
```
